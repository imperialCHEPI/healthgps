<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Health-GPS: Number Handling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Health-GPS
   &#160;<span id="projectnumber">1.2.2.0</span>
   </div>
   <div id="projectbrief">Global Health Policy Simulation model (Health-GPS)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_runner_work_healthgps_healthgps_vcpkg_buildtrees_nlohmann_json_src_v3_11_2_efdad4750e_ca1f60ca2e0976e788ea37b25f470bec0.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Number Handling </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document describes how the library is handling numbers.</p>
<h1><a class="anchor" id="autotoc_md2261"></a>
Background</h1>
<p>This section briefly summarizes how the JSON specification describes how numbers should be handled.</p>
<h2><a class="anchor" id="autotoc_md2262"></a>
JSON number syntax</h2>
<p>JSON defines the syntax of numbers as follows:</p>
<p>!!! quote "[RFC 8259](https://tools.ietf.org/html/rfc8259#section-6), Section 6" </p><pre class="fragment">The representation of numbers is similar to that used in most
programming languages.  A number is represented in base 10 using
decimal digits.  It contains an integer component that may be
prefixed with an optional minus sign, which may be followed by a
fraction part and/or an exponent part.  Leading zeros are not
allowed.

A fraction part is a decimal point followed by one or more digits.

An exponent part begins with the letter E in uppercase or lowercase,
which may be followed by a plus or minus sign.  The E and optional
sign are followed by one or more digits.
</pre><p> The following railroad diagram from <a href="https://json.org">json.org</a> visualizes the number syntax:</p>
<p><img src="../../images/json_syntax_number.png" alt="Syntax for JSON numbers" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md2263"></a>
Number interoperability</h2>
<p>On number interoperability, the following remarks are made:</p>
<p>!!! quote "[RFC 8259](https://tools.ietf.org/html/rfc8259#section-6), Section 6" </p><pre class="fragment">This specification allows implementations to set limits on the range
and precision of numbers accepted.  Since software that implements
IEEE 754 binary64 (double precision) numbers [IEEE754] is generally
available and widely used, good interoperability can be achieved by
implementations that expect no more precision or range than these
provide, in the sense that implementations will approximate JSON
numbers within the expected precision.  A JSON number such as 1E400
or 3.141592653589793238462643383279 may indicate potential
interoperability problems, since it suggests that the software that
created it expects receiving software to have greater capabilities
for numeric magnitude and precision than is widely available.

Note that when such software is used, numbers that are integers and
are in the range $[-2^{53}+1, 2^{53}-1]$ are interoperable in the
sense that implementations will agree exactly on their numeric
values.
</pre> <h1><a class="anchor" id="autotoc_md2264"></a>
Library implementation</h1>
<p>This section describes how the above number specification is implemented by this library.</p>
<h2><a class="anchor" id="autotoc_md2265"></a>
Number storage</h2>
<p>In the default <a class="el" href="md__home_runner_work_healthgps_healthgps_vcpkg_buildtrees_nlohmann_json_src_v3_11_2_efdad4750e_clean_docs_mkdocs_docs_api_json.html">`json`</a> type, numbers are stored as <code>#!c std::uint64_t</code>, <code>#!c std::int64_t</code>, and <code>#!c double</code>, respectively. Thereby, <code>#!c std::uint64_t</code> and <code>#!c std::int64_t</code> are used only if they can store the number without loss of precision. If this is impossible (e.g., if the number is too large), the number is stored as <code>#!c double</code>.</p>
<p>!!! info "Notes" </p><pre class="fragment">- Numbers with a decimal digit or scientific notation are always stored as `#!c double`.
- The number types can be changed, see [Template number types](#template-number-types). 
- As of version 3.9.1, the conversion is realized by
  [`std::strtoull`](https://en.cppreference.com/w/cpp/string/byte/strtoul),
  [`std::strtoll`](https://en.cppreference.com/w/cpp/string/byte/strtol), and
  [`std::strtod`](https://en.cppreference.com/w/cpp/string/byte/strtof), respectively.
</pre><p> !!! example "Examples" </p><pre class="fragment">- Integer `#!c -12345678912345789123456789` is smaller than `#!c INT64_MIN` and will be stored as floating-point
  number `#!c -1.2345678912345788e+25`.
- Integer `#!c 1E3` will be stored as floating-point number `#!c 1000.0`.
</pre> <h2><a class="anchor" id="autotoc_md2266"></a>
Number limits</h2>
<ul>
<li>Any 64-bit signed or unsigned integer can be stored without loss of precision.</li>
<li>Numbers exceeding the limits of <code>#!c double</code> (i.e., numbers that after conversion via <a href="https://en.cppreference.com/w/cpp/string/byte/strtof"><code>std::strtod</code></a> are not satisfying <a href="https://en.cppreference.com/w/cpp/numeric/math/isfinite"><code>std::isfinite</code></a> such as <code>#!c 1E400</code>) will throw exception <a href="../../home/exceptions.md#jsonexceptionout_of_range406"><code>json.exception.out_of_range.406</code></a> during parsing.</li>
<li>Floating-point numbers are rounded to the next number representable as <code>double</code>. For instance <code>#!c 3.141592653589793238462643383279</code> is stored as <a href="https://float.exposed/0x400921fb54442d18"><code>0x400921fb54442d18</code></a>. This is the same behavior as the code <code>#!c double x = 3.141592653589793238462643383279;</code>.</li>
</ul>
<p>!!! success "Interoperability" </p><pre class="fragment">- The library interoperable with respect to the specification, because its supported range $[-2^{63}, 2^{64}-1]$ is
  larger than the described range $[-2^{53}+1, 2^{53}-1]$.
- All integers outside the range $[-2^{63}, 2^{64}-1]$, as well as floating-point numbers are stored as `double`.
  This also concurs with the specification above.
</pre> <h2><a class="anchor" id="autotoc_md2267"></a>
Zeros</h2>
<p>The JSON number grammar allows for different ways to express zero, and this library will store zeros differently:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Literal   </th><th class="markdownTableHeadNone">Stored value and type   </th><th class="markdownTableHeadNone">Serialization    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>0</code>   </td><td class="markdownTableBodyNone"><code>#!c std::uint64_t(0)</code>   </td><td class="markdownTableBodyNone"><code>0</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-0</code>   </td><td class="markdownTableBodyNone"><code>#!c std::int64_t(0)</code>   </td><td class="markdownTableBodyNone"><code>0</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>0.0</code>   </td><td class="markdownTableBodyNone"><code>#!c double(0.0)</code>   </td><td class="markdownTableBodyNone"><code>0.0</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-0.0</code>   </td><td class="markdownTableBodyNone"><code>#!c double(-0.0)</code>   </td><td class="markdownTableBodyNone"><code>-0.0</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>0E0</code>   </td><td class="markdownTableBodyNone"><code>#!c double(0.0)</code>   </td><td class="markdownTableBodyNone"><code>0.0</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>-0E0</code>   </td><td class="markdownTableBodyNone"><code>#!c double(-0.0)</code>   </td><td class="markdownTableBodyNone"><code>-0.0</code>   </td></tr>
</table>
<p>That is, <code>-0</code> is stored as a signed integer, but the serialization does not reproduce the <code>-</code>.</p>
<h2><a class="anchor" id="autotoc_md2268"></a>
Number serialization</h2>
<ul>
<li>Integer numbers are serialized as is; that is, no scientific notation is used.</li>
<li>Floating-point numbers are serialized as specified by the <code>#!c g</code> printf modifier with <a href="https://en.cppreference.com/w/cpp/types/numeric_limits/max_digits10"><code>std::numeric_limits&lt;double&gt;::max_digits10</code></a> significant digits. The rationale is to use the shortest representation while still allow round-tripping.</li>
</ul>
<p>!!! hint "Notes regarding precision of floating-point numbers" </p><pre class="fragment">As described above, floating-point numbers are rounded to the nearest double and serialized with the shortest
representation to allow round-tripping. This can yield confusing examples:

- The serialization can have fewer decimal places than the input: `#!c 2555.5599999999999` will be serialized as
  `#!c 2555.56`. The reverse can also be true.
- The serialization can be in scientific notation even if the input is not: `#!c 0.0000972439793401814` will be 
  serialized as `#!c 9.72439793401814e-05`. The reverse can also be true: `#!c 12345E-5` will be serialized as
  `#!c 0.12345`.
- Conversions from `#!c float` to `#!c double` can also introduce rounding errors:
    ```cpp
    float f = 0.3;
    json j = f;
    std::cout &lt;&lt; j &lt;&lt; '\n';
    ```
    yields `#!c 0.30000001192092896`.

All examples here can be reproduced by passing the original double value to

```cpp
std::printf("%.*g\n", std::numeric_limits&lt;double&gt;::max_digits10, double_value);
```
</pre> <h3><a class="anchor" id="autotoc_md2269"></a>
NaN handling</h3>
<p>NaN (not-a-number) cannot be expressed with the number syntax described above and are in fact explicitly excluded:</p>
<p>!!! quote "[RFC 8259](https://tools.ietf.org/html/rfc8259#section-6), Section 6" </p><pre class="fragment">Numeric values that cannot be represented in the grammar below (such
as Infinity and NaN) are not permitted.
</pre><p> That is, there is no way to <em>parse</em> a NaN value. However, NaN values can be stored in a JSON value by assignment.</p>
<p>This library serializes NaN values as <code>#!js null</code>. This corresponds to the behavior of JavaScript's <a href="https://www.w3schools.com/js/js_json_stringify.asp"><code>JSON.stringify</code></a> function.</p>
<p>!!! example </p><pre class="fragment">The following example shows how a NaN value is stored in a `json` value.

```cpp
int main()
{
    double val = std::numeric_limits&lt;double&gt;::quiet_NaN();
    std::cout &lt;&lt; "val=" &lt;&lt; val &lt;&lt; std::endl;
    json j = val;
    std::cout &lt;&lt; "j=" &lt;&lt; j.dump() &lt;&lt; std::endl;
    val = j;
    std::cout &lt;&lt; "val=" &lt;&lt; val &lt;&lt; std::endl;
}
```

output:

```
val=nan
j=null
val=nan
```
</pre> <h2><a class="anchor" id="autotoc_md2270"></a>
Number comparison</h2>
<p>Floating-point inside JSON values numbers are compared with <code>#!c json::number_float_t::operator==</code> which is <code>#!c double::operator==</code> by default.</p>
<p>!!! example "Alternative comparison functions" </p><pre class="fragment">To compare floating-point while respecting an epsilon, an alternative
[comparison function](https://github.com/mariokonrad/marnav/blob/master/include/marnav/math/floatingpoint.hpp#L34-#L39)
could be used, for instance

```cpp
template&lt;typename T, typename = typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, T&gt;::type&gt;
inline bool is_same(T a, T b, T epsilon = std::numeric_limits&lt;T&gt;::epsilon()) noexcept
{
    return std::abs(a - b) &lt;= epsilon;
}
```
Or you can self-define an operator equal function like this:

```cpp
bool my_equal(const_reference lhs, const_reference rhs)
{
    const auto lhs_type lhs.type();
    const auto rhs_type rhs.type();
    if (lhs_type == rhs_type)
    {
        switch(lhs_type)
        {
            // self_defined case
            case value_t::number_float:
                return std::abs(lhs - rhs) &lt;= std::numeric_limits&lt;float&gt;::epsilon();

            // other cases remain the same with the original
            ...
        }
    }
    ...
}
```

(see [#703](https://github.com/nlohmann/json/issues/703) for more information.)
</pre><p> !!! note </p><pre class="fragment">NaN values never compare equal to themselves or to other NaN values. See [#514](https://github.com/nlohmann/json/issues/514).
</pre> <h2><a class="anchor" id="autotoc_md2271"></a>
Number conversion</h2>
<p>Just like the C++ language itself, the <code>get</code> family of functions allows conversions between unsigned and signed integers, and between integers and floating-point values to integers. This behavior may be surprising.</p>
<p>!!! warning "Unconditional number conversions" </p><pre class="fragment">```cpp hl_lines="3"
double d = 42.3;                          // non-integer double value 42.3
json jd = d;                              // stores double value 42.3
std::int64_t i = jd.get&lt;std::int64_t&gt;();  // now i==42; no warning or error is produced
```

Note the last line with throw a [`json.exception.type_error.302`](../../home/exceptions.md#jsonexceptiontype_error302)
exception if `jd` is not a numerical type, for instance a string.
</pre><p> The rationale is twofold:</p>
<ol type="1">
<li>JSON does not define a number type or precision (see [<a class="el" href="vcpkg_2packages_2nlohmann-json__x64-linux_2include_2nlohmann_2json__fwd_8hpp.html#ae6eede511f01c9f33342044d36a388fa" title="default specialization">json</a>-specification](above)).</li>
<li>C++ also allows to silently convert between number types.</li>
</ol>
<p>!!! success "Conditional number conversion" </p><pre class="fragment">The code above can be solved by explicitly checking the nature of the value with members such as
[`is_number_integer()`](../../api/basic_json/is_number_integer.md) or
[`is_number_unsigned()`](../../api/basic_json/is_number_unsigned.md):

```cpp hl_lines="2"
// check if jd is really integer-valued
if (jd.is_number_integer())
{
    // if so, do the conversion and use i
    std::int64_t i = jd.get&lt;std::int64_t&gt;();
    // ...
}
else
{
    // otherwise, take appropriate action
    // ...
}
```

Note this approach also has the advantage that it can react on non-numerical JSON value types such as strings.

(Example taken from [#777](https://github.com/nlohmann/json/issues/777#issuecomment-459968458).)
</pre> <h2><a class="anchor" id="autotoc_md2272"></a>
Determine number types</h2>
<p>As the example in <a href="#number-conversion">Number conversion</a> shows, there are different functions to determine the type of the stored number:</p>
<ul>
<li><a class="el" href="md__home_runner_work_healthgps_healthgps_vcpkg_buildtrees_nlohmann_json_src_v3_11_2_efdad4750e_c887224c12acb73f378307a0ecad64edd.html">`is_number()`</a> returns <code>#!c true</code> for any number type</li>
<li><a class="el" href="md__home_runner_work_healthgps_healthgps_vcpkg_buildtrees_nlohmann_json_src_v3_11_2_efdad4750e_cbdad2df99383267151abca05b6a5522e.html">`is_number_integer()`</a> returns <code>#!c true</code> for signed and unsigned integers</li>
<li><a class="el" href="md__home_runner_work_healthgps_healthgps_vcpkg_buildtrees_nlohmann_json_src_v3_11_2_efdad4750e_c2baf85332703671584023bc2db6db235.html">`is_number_unsigned()`</a> returns <code>#!c true</code> for unsigned integers only</li>
<li><a class="el" href="md__home_runner_work_healthgps_healthgps_vcpkg_buildtrees_nlohmann_json_src_v3_11_2_efdad4750e_c21fed94d0e3ceb8b553a083b0c4d4e01.html">`is_number_float()`</a> returns <code>#!c true</code> for floating-point numbers</li>
<li><a class="el" href="md__home_runner_work_healthgps_healthgps_vcpkg_buildtrees_nlohmann_json_src_v3_11_2_efdad4750e_c067f7a07c6237c67bc2b21bfaddf78f2.html">`type_name()`</a> returns <code>#!c "number"</code> for any number type</li>
<li><a class="el" href="md__home_runner_work_healthgps_healthgps_vcpkg_buildtrees_nlohmann_json_src_v3_11_2_efdad4750e_c1abbcd32a1d72faa3d326957eb281e6f.html">`type()`</a> returns a different enumerator of <a class="el" href="md__home_runner_work_healthgps_healthgps_vcpkg_buildtrees_nlohmann_json_src_v3_11_2_efdad4750e_ceafc2f31c8d52ab2bc910b1b076fb707.html">`value_t`</a> for all number types</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">function   </th><th class="markdownTableHeadNone">unsigned integer   </th><th class="markdownTableHeadNone">signed integer   </th><th class="markdownTableHeadNone">floating-point   </th><th class="markdownTableHeadNone">string    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md__home_runner_work_healthgps_healthgps_vcpkg_buildtrees_nlohmann_json_src_v3_11_2_efdad4750e_c887224c12acb73f378307a0ecad64edd.html">`is_number()`</a>   </td><td class="markdownTableBodyNone"><code>#!c true</code>   </td><td class="markdownTableBodyNone"><code>#!c true</code>   </td><td class="markdownTableBodyNone"><code>#!c true</code>   </td><td class="markdownTableBodyNone"><code>#!c false</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="md__home_runner_work_healthgps_healthgps_vcpkg_buildtrees_nlohmann_json_src_v3_11_2_efdad4750e_cbdad2df99383267151abca05b6a5522e.html">`is_number_integer()`</a>   </td><td class="markdownTableBodyNone"><code>#!c true</code>   </td><td class="markdownTableBodyNone"><code>#!c true</code>   </td><td class="markdownTableBodyNone"><code>#!c false</code>   </td><td class="markdownTableBodyNone"><code>#!c false</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md__home_runner_work_healthgps_healthgps_vcpkg_buildtrees_nlohmann_json_src_v3_11_2_efdad4750e_c2baf85332703671584023bc2db6db235.html">`is_number_unsigned()`</a>   </td><td class="markdownTableBodyNone"><code>#!c true</code>   </td><td class="markdownTableBodyNone"><code>#!c false</code>   </td><td class="markdownTableBodyNone"><code>#!c false</code>   </td><td class="markdownTableBodyNone"><code>#!c false</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="md__home_runner_work_healthgps_healthgps_vcpkg_buildtrees_nlohmann_json_src_v3_11_2_efdad4750e_c21fed94d0e3ceb8b553a083b0c4d4e01.html">`is_number_float()`</a>   </td><td class="markdownTableBodyNone"><code>#!c false</code>   </td><td class="markdownTableBodyNone"><code>#!c false</code>   </td><td class="markdownTableBodyNone"><code>#!c true</code>   </td><td class="markdownTableBodyNone"><code>#!c false</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="md__home_runner_work_healthgps_healthgps_vcpkg_buildtrees_nlohmann_json_src_v3_11_2_efdad4750e_c067f7a07c6237c67bc2b21bfaddf78f2.html">`type_name()`</a>   </td><td class="markdownTableBodyNone"><code>#!c "number"</code>   </td><td class="markdownTableBodyNone"><code>#!c "number"</code>   </td><td class="markdownTableBodyNone"><code>#!c "number"</code>   </td><td class="markdownTableBodyNone"><code>#!c "string"</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="md__home_runner_work_healthgps_healthgps_vcpkg_buildtrees_nlohmann_json_src_v3_11_2_efdad4750e_c1abbcd32a1d72faa3d326957eb281e6f.html">`type()`</a>   </td><td class="markdownTableBodyNone"><code><a class="el" href="classnumber__unsigned.html">number_unsigned</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="classnumber__integer.html">number_integer</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="classnumber__float.html">number_float</a></code>   </td><td class="markdownTableBodyNone"><code>string</code>   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2273"></a>
Template number types</h2>
<p>The number types can be changed with template parameters.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">position   </th><th class="markdownTableHeadNone">number type   </th><th class="markdownTableHeadNone">default type   </th><th class="markdownTableHeadNone">possible values    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">signed integers   </td><td class="markdownTableBodyNone"><code>#!c std::int64_t</code>   </td><td class="markdownTableBodyNone"><code>#!c std::int32_t</code>, <code>#!c std::int16_t</code>, etc.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">unsigned integers   </td><td class="markdownTableBodyNone"><code>#!c std::uint64_t</code>   </td><td class="markdownTableBodyNone"><code>#!c std::uint32_t</code>, <code>#!c std::uint16_t</code>, etc.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">7   </td><td class="markdownTableBodyNone">floating-point   </td><td class="markdownTableBodyNone"><code>#!c double</code>   </td><td class="markdownTableBodyNone"><code>#!c float</code>, <code>#!c long double</code>   </td></tr>
</table>
<p>!!! info "Constraints on number types" </p><pre class="fragment">- The type for signed integers must be convertible from `#!c long long`. The type for floating-point numbers is used
  in case of overflow.
- The type for unsigned integers must be convertible from `#!c unsigned long long`.  The type for floating-point
  numbers is used in case of overflow.
- The types for signed and unsigned integers must be distinct, see
  [#2573](https://github.com/nlohmann/json/issues/2573).
- Only `#!c double`, `#!c float`, and `#!c long double` are supported for floating-point numbers.
</pre><p> !!! example </p><pre class="fragment">A `basic_json` type that uses `#!c long double` as floating-point type.

```cpp hl_lines="2"
using json_ld = nlohmann::basic_json&lt;std::map, std::vector, std::string, bool,
                                     std::int64_t, std::uint64_t, long double&gt;;
```

Note values should then be parsed with `json_ld::parse` rather than `json::parse` as the latter would parse
floating-point values to `#!c double` before then converting them to `#!c long double`.
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
