<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Health-GPS: Proposal: Features / Feature packages (Feb 23 2017)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Health-GPS
   &#160;<span id="projectnumber">1.2.2.0</span>
   </div>
   <div id="projectbrief">Global Health Policy Simulation model (Health-GPS)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_runner_work_healthgps_healthgps_vcpkg_docs_specifications_feature_packages.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Proposal: Features / Feature packages (Feb 23 2017) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Note: this is the feature as it was initially specified and does not necessarily reflect the current behavior.</b></p>
<p><b>Up-to-date documentation is available at <a class="el" href="md__home_runner_work_healthgps_healthgps_vcpkg_docs_users_selecting_library_features.html">Selecting Library Features</a>.</b></p>
<h1><a class="anchor" id="autotoc_md3781"></a>
1. Motivation</h1>
<h2><a class="anchor" id="autotoc_md3782"></a>
A. OpenCV + CUDA</h2>
<p><a href="http://opencv.org/">OpenCV</a> is a computer vision library that can optionally be built with CUDA support to massively accelerate certain tasks when using computers with NVidia GPUs. For users without NVidia GPUs, building with CUDA support provides no benefit. <a href="http://www.nvidia.com/object/cuda_home_new.html">CUDA</a> is provided only via a 1.3 GB installer (at the time of this authoring), which requires administrator access to install and modifies the global system state.</p>
<p>Therefore, there is significant value in enabling users to choose whether they find CUDA support valuable for their particular scenario.</p>
<h2><a class="anchor" id="autotoc_md3783"></a>
B. OpenCV + OpenCV_contrib</h2>
<p>The community around <a href="http://opencv.org/">OpenCV</a> has built up a library of extensions called <a href="https://github.com/opencv/opencv_contrib">OpenCV_contrib</a>. However, these extensions are a source-level patch onto the main OpenCV codebase and therefore must be applied <em>during</em> the core OpenCV build. Further confounding the problem, it is the author's understanding that these community extensions have only been developed with <a href="http://www.nvidia.com/object/cuda_home_new.html">CUDA</a> enabled and cannot be built without that dependency.</p>
<p>Therefore, if CUDA is disabled, OpenCV_contrib must also be disabled. Likewise, when a user requests OpenCV_contrib, CUDA must be enabled. It would be convenient, but not a requirement, to enable CUDA without enabling the community extensions.</p>
<p>Finally, these extensions add additional exports and headers which could be depended upon by other libraries. For maintainers, there must be a way to specify this requirement such that <code>vcpkg install mylib-depends-ocv-contrib</code> will verify/build/rebuild OpenCV with the community extensions enabled.</p>
<h2><a class="anchor" id="autotoc_md3784"></a>
C. C++ REST SDK + SignalR</h2>
<p>The <a href="https://github.com/Microsoft/cpprestsdk">C++ REST SDK</a> is a networking library that provides (among other features) HTTP and Websockets clients. To implement the HTTP client functionality on Windows Desktop, only the core Win32 platform APIs are needed (<code>zlib</code> is optional).</p>
<p>However, the websockets client is based on <a href="https://www.zaphoyd.com/websocketpp/">Websockets++</a>, which adds mandatory dependencies on <code>boost</code>, <code>openssl</code>, and <code>zlib</code>. Many users of the C++ REST SDK do not use the websockets component, so to minimize their overall dependency footprint it can be disabled at build time. Ideally, these kinds of options would be easily accessible to users in Vcpkg who are concerned about the final size or licensing of their deployment.</p>
<p><a href="https://github.com/aspnet/SignalR-Client-Cpp">SignalR-Client-Cpp</a> depends on the websockets functionality provided by the C++ REST SDK. Therefore, the maintainers of the <code>signalrclient</code> port would ideally like to express this dependency such that <code>cpprestsdk</code> will be automatically correctly built for their needs. Note that <code>signalrclient</code> does not <em>inherently</em> care about <code>boost</code>, <code>websocketspp</code> or <code>openssl</code> &ndash; it depends only on the public websocket client APIs provided by <code>cpprestsdk</code>. It would be much more maintainable to declare dependencies based on the public APIs rather than the dependencies themselves.</p>
<h1><a class="anchor" id="autotoc_md3785"></a>
2. Other design concerns</h1>
<ul>
<li>General-purpose Open Source projects must be able to easily and succinctly describe their build dependencies inside Vcpkg. This should be no more verbose than a single <code>vcpkg install</code> line and, when that command succeeds, there is a strong expectation that all required functionality/headers/imports are available.</li>
<li>The internal state of the Vcpkg enlistment must be either extremely transparent OR managed by version control (git). This enables larger projects to efficiently transfer the entire state of their customized Vcpkg system between machines (and onto build servers) by having the destination clone and then run a single <code>vcpkg install</code> line for the subset of dependencies required. The results of this operation should be as repeatable as reasonably achievable given the current limits of the underlying toolchain.</li>
</ul>
<h1><a class="anchor" id="autotoc_md3786"></a>
3. Proposed solution</h1>
<p>A key summary of the above motivations is that they are all scenarios surrounding APIs that are not independently buildable from each other. We have an existing solution for APIs that are independently buildable: separate packages. Therefore, we seek to extend the user-facing notion of "packages" to include capabilities and contracts that cannot be made into independent builds.</p>
<p>This document proposes "features" (also called feature packages). These features are intended to model semi-independently toggleable API sets/contracts such that they can be sanely depended upon by other packages. It is not a goal to model exclusive alternatives (such as implementation choices that are not directly user-observable) through this mechanism.</p>
<ul>
<li>Individual libraries within <code>boost</code> may be reasonably represented as features.</li>
<li>Whether a graphics library is built on DirectX xor OpenGL (where one but not both must be chosen) is not representable as a feature.</li>
</ul>
<p>From a user experience perspective (i.e. from <code>vcpkg install</code>) feature packages act as much as possible like completely independent packages. However, internally, any change to a package's features will result in a rebuild of the associated "parent" package. This will invoke a package rebuild experience similar to upgrading.</p>
<p>When using <code>vcpkg install &lt;package&gt;</code>, some features will be enabled by default. These default features can be avoided by referring to the packages as <code>&lt;package&gt;[core]</code> and features can be added by supplying them on the same installation line.</p>
<h2><a class="anchor" id="autotoc_md3787"></a>
A. Proposed User experience</h2>
<h3><a class="anchor" id="autotoc_md3788"></a>
i. User with no preference about options</h3>
<p>Install of a library with default features: </p><div class="fragment"><div class="line">&gt; vcpkg install cpprestsdk</div>
<div class="line">// -- omitted build information -- //</div>
<div class="line">Package cpprestsdk[core]:x86-windows is installed.</div>
<div class="line">Package cpprestsdk[compression]:x86-windows is installed.</div>
<div class="line">Package cpprestsdk[ws-client]:x86-windows is installed.</div>
</div><!-- fragment --><p>Removal of that library: </p><div class="fragment"><div class="line">&gt; vcpkg remove cpprestsdk</div>
<div class="line">The following packages will be removed:</div>
<div class="line">    cpprestsdk:x86-windows</div>
<div class="line">Removing package cpprestsdk:x86-windows...</div>
<div class="line">Removing package cpprestsdk:x86-windows... done</div>
<div class="line">Purging package cpprestsdk:x86-windows...</div>
<div class="line">Cleaned up D:\src\vcpkg\packages\cpprestsdk_x64-windows</div>
<div class="line">Purging package cpprestsdk:x86-windows... done</div>
</div><!-- fragment --><p>Installation of a library with optional features: </p><div class="fragment"><div class="line">&gt; vcpkg install opencv</div>
<div class="line">// -- omitted build information -- //</div>
<div class="line">Package opencv[core]:x86-windows is installed.</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md3789"></a>
ii. User desires CUDA support for OpenCV directly, and is unfamiliar with feature packages</h3>
<p>Developer Bob knows he wants OpenCV, so he guesses what the package is called </p><div class="fragment"><div class="line">&gt; vcpkg install opencv</div>
<div class="line">// -- omitted build information -- //</div>
<div class="line">Package opencv[core]:x86-windows is installed.</div>
</div><!-- fragment --><p>Bob attempts to build his application against OpenCV (assuming CUDA), which fails at runtime or compile time indicating that OpenCV wasn't built with CUDA. Bob comes back to vcpkg, not knowing about the "feature packages" feature. The primary inquiry tools for Vcpkg are <code>search</code> and <code>list</code>, so he runs <code>vcpkg search</code>: </p><div class="fragment"><div class="line">&gt; vcpkg search opencv</div>
<div class="line">opencv               3.2.0            computer vision library</div>
<div class="line">opencv[cuda]                          support for NVidia CUDA</div>
<div class="line">opencv[contrib]                       community supported extensions for OpenCV</div>
<div class="line"> </div>
<div class="line">If your library is not listed, please open an issue at:</div>
<div class="line">    https://github.com/Microsoft/vcpkg/issues</div>
</div><!-- fragment --><p> He isn't immediately sure what the lack of a version number means, but anything in <code>vcpkg search</code> can be applied to <code>vcpkg install</code>, so he runs: </p><div class="fragment"><div class="line">&gt; vcpkg install opencv[cuda]</div>
<div class="line">The following packages will be rebuilt:</div>
<div class="line">    opencv:x86-windows</div>
<div class="line"> </div>
<div class="line">To rebuild with this feature, use:</div>
<div class="line">    vcpkg remove opencv:x86-windows</div>
<div class="line">    vcpkg install opencv[core,cuda]:x86-windows</div>
</div><!-- fragment --><p> Bob follows the instructions... </p><div class="fragment"><div class="line">&gt; vcpkg remove opencv:x86-windows</div>
<div class="line">// -- omitted results as above -- //</div>
<div class="line">&gt; vcpkg install opencv[core,cuda]:x86-windows</div>
<div class="line">// -- omitted build information -- //</div>
<div class="line">Package opencv[core]:x86-windows is installed.</div>
<div class="line">Package opencv[cuda]:x86-windows is installed.</div>
</div><!-- fragment --><p> and he can now use OpenCV's CUDA support in his application.</p>
<h3><a class="anchor" id="autotoc_md3790"></a>
iii. User is familiar with feature packages, and wants to opt-out of a feature</h3>
<p>Developer Alice has used <code>cpprestsdk</code>, built it from source, and she knows about the option to disable websockets. She uses <code>search</code> to find the complete list of features: </p><div class="fragment"><div class="line">&gt; vcpkg search cpprestsdk</div>
<div class="line">cpprestsdk                  2.9.0-2       C++11 JSON, REST, and OAuth library The C++ RES...</div>
<div class="line">cpprestsdk[compression]                   Gzip compression support in the HTTP client.</div>
<div class="line">cpprestsdk[ws-client]                     Websocket client support based on websocketspp.</div>
<div class="line"> </div>
<div class="line">If your library is not listed, please open an issue at:</div>
<div class="line">    https://github.com/Microsoft/vcpkg/issues</div>
</div><!-- fragment --><p>She decided she only wants <code>cpprestsdk[compression]</code>, so she installs only that feature: </p><div class="fragment"><div class="line">&gt; vcpkg install cpprestsdk[compression]</div>
<div class="line">// -- omitted build information -- //</div>
<div class="line">Package cpprestsdk[core]:x86-windows is installed.</div>
<div class="line">Package cpprestsdk[compression]:x86-windows is installed.</div>
</div><!-- fragment --><p> She receives a quick recursive build that only depends on <code>zlib</code>.</p>
<p>She's now interested in some additional libraries built on top of cpprestsdk: <code>azure-storage-cpp</code> and <code>signalrclient</code>. </p><div class="fragment"><div class="line">&gt; vcpkg install azure-storage-cpp</div>
<div class="line">// -- omitted build information -- //</div>
<div class="line">Package azure-storage-cpp[core]:x86-windows is installed.</div>
<div class="line"> </div>
<div class="line">&gt; vcpkg install signalrclient</div>
<div class="line">Package signalrclient:x86-windows depends on cpprestsdk[ws-client]:x86-windows.</div>
<div class="line"> </div>
<div class="line">The following packages will be rebuilt:</div>
<div class="line">  * azure-storage-cpp:x86-windows</div>
<div class="line">  * cpprestsdk:x86-windows</div>
<div class="line"> </div>
<div class="line">To rebuild the current package graph with this feature, use:</div>
<div class="line">    vcpkg remove cpprestsdk:x86-windows azure-storage-cpp:x86-windows</div>
<div class="line">    vcpkg install cpprestsdk[core,compression,ws-client]:x86-windows</div>
<div class="line">    vcpkg install azure-storage-cpp[core]:x86-windows</div>
<div class="line">    vcpkg install signalrclient[core]:x86-windows</div>
</div><!-- fragment --><p> She follows the above script and can use both <code>azure-storage-cpp</code> and <code>signalrclient</code> in her code.</p>
<p>Some time has passed, she decided not to use <code>signalrclient</code>, and she's interested in shipping her application. She wants to minimize her final install size, so she'd like to remove all unneeded packages like <code>boost</code> and <code>openssl</code>. </p><div class="fragment"><div class="line">&gt; vcpkg remove boost openssl</div>
<div class="line">The following packages and features will be removed:</div>
<div class="line">  * signalrclient[core]:x86-windows</div>
<div class="line">  * cpprestsdk[ws-client]:x86-windows</div>
<div class="line">    boost[core]:x86-windows</div>
<div class="line">    openssl[core]:x86-windows</div>
<div class="line"> </div>
<div class="line">The following packages will be rebuilt:</div>
<div class="line">  * azure-storage-cpp:x86-windows</div>
<div class="line">  * cpprestsdk:x86-windows</div>
<div class="line"> </div>
<div class="line">Removing features requires rebuilding packages.</div>
<div class="line">To rebuild the current package graph without these features, use:</div>
<div class="line">    vcpkg remove cpprestsdk:x86-windows azure-storage-cpp:x86-windows signalrclient:x86-windows openssl:x86-windows boost:x86-windows</div>
<div class="line">    vcpkg install cpprestsdk[core,compression]:x86-windows</div>
<div class="line">    vcpkg install azure-storage-cpp[core]:x86-windows</div>
</div><!-- fragment --><p> In the end, her final <code>vcpkg list</code> outputs: </p><div class="fragment"><div class="line">&gt; vcpkg list</div>
<div class="line">zlib[core]:x86-windows              1.2.11          A compression library</div>
<div class="line">azure-storage-cpp[core]:x86-windows 2.6.0           Microsoft Azure Storage Client SDK for ...</div>
<div class="line">cpprestsdk[core]:x86-windows        2.9.0-2         C++11 JSON, REST, and OAuth library</div>
<div class="line">cpprestsdk[compression]:x86-windows                 Gzip compression support in the HTTP client.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3791"></a>
B. Technical model</h2>
<ul>
<li>Each package can have any number "features".</li>
<li>Features follow the same naming conventions as packages, but when referenced are always "namespaced" by the parent package.<ul>
<li><code>cpprestsdk[ws-client]</code> is a completely orthogonal feature from <code>poco[ws-client]</code>.</li>
</ul>
</li>
<li>Features are valid dependencies.<ul>
<li><code>signalrclient</code> depends on <code>cpprestsdk[ws-client]</code></li>
</ul>
</li>
<li>Features can have dependencies (including other features).<ul>
<li><code>cpprestsdk[ws-client]</code> depends on <code>boost</code>, <code>openssl</code>, and <code>websocketspp</code></li>
<li><code>opencv[cuda]</code> depends on <code>cuda</code></li>
<li><code>opencv[contrib]</code> depends on <code>opencv[cuda]</code></li>
<li><code>boost[python]</code> depends on <code>libpython</code></li>
</ul>
</li>
<li>Every package has an implicit feature called <code>core</code>, which covers the core library with a minimum set of features. All features implicitly depend on the <code>core</code> feature of their parent package<ul>
<li><code>azure-storage-cpp</code> depends on <code>cpprestsdk[core]</code></li>
<li><code>cpprestsdk[ws-client]</code> implicitly depends on <code>cpprestsdk[core]</code></li>
</ul>
</li>
<li>Each package declares a list of default features that are enabled when the package is referred to by its raw name, and <code>core</code> is always a default feature.<ul>
<li><code>cpprestsdk</code> declares <code>ws-client</code> and <code>compression</code> to be default features. Any unqualified reference <code>cpprestsdk</code> implicitly means <code>cpprestsdk[core]</code> <em>and</em> <code>cpprestsdk[ws-client]</code> <em>and</em> <code>cpprestsdk[compression]</code>.</li>
<li><code>opencv</code> does not declare <code>cuda</code> nor <code>contrib</code> to be default features.</li>
</ul>
</li>
</ul>
<p>As a conclusion of the above, it is expected that all packages will be buildable with all features disabled (just the <code>core</code> feature) and with all features enabled.</p>
<h2><a class="anchor" id="autotoc_md3792"></a>
C. Proposed Control File Syntax</h2>
<h3><a class="anchor" id="autotoc_md3793"></a>
OpenCV and CUDA</h3>
<p>To add the feature CUDA to OpenCV, we will adopt the following syntax in the CONTROL file: </p><div class="fragment"><div class="line"># opencv/CONTROL</div>
<div class="line">Source: opencv</div>
<div class="line">Version: 3.2.0-1</div>
<div class="line">Build-Depends: zlib, libpng, libjpeg-turbo, tiff</div>
<div class="line">Description: computer vision library</div>
<div class="line">Default-Features:</div>
<div class="line"> </div>
<div class="line">Feature: cuda</div>
<div class="line">Build-Depends: cuda</div>
<div class="line">Description: parallel computing platform</div>
<div class="line"> </div>
<div class="line">Feature: contrib</div>
<div class="line">Build-Depends: opencv[cuda]</div>
<div class="line">Description: library of OpenCV Extensions</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md3794"></a>
Signalrclient</h3>
<div class="fragment"><div class="line"># signalrclient/CONTROL</div>
<div class="line">Source: signalrclient</div>
<div class="line">Version: 1.0.0-beta1</div>
<div class="line">Build-Depends: cpprestsdk[ws-client]</div>
<div class="line">Description: C++ client for SignalR.</div>
</div><!-- fragment --> <div class="fragment"><div class="line"># cpprestsdk/CONTROL</div>
<div class="line">Source: cpprestsdk</div>
<div class="line">Version: 2.9.0-2</div>
<div class="line">Build-Depends: </div>
<div class="line">Description: C++11 JSON, REST, and OAuth library ...</div>
<div class="line">Default-Features: compression, ws-client</div>
<div class="line"> </div>
<div class="line">Feature: compression</div>
<div class="line">Build-Depends: zlib (windows)</div>
<div class="line">Description: Gzip compression support in the HTTP client.</div>
<div class="line"> </div>
<div class="line">Feature: ws-client</div>
<div class="line">Build-Depends: boost (windows), openssl (windows), websocketpp (windows)</div>
<div class="line">Description: Websocket client support based on websocketspp</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3795"></a>
D. Additional Control File Technical Details</h2>
<ul>
<li>If any feature paragraphs exist, the field <code>Default-Features</code> must be present.</li>
</ul>
<h1><a class="anchor" id="autotoc_md3796"></a>
4. Related Work</h1>
<h2><a class="anchor" id="autotoc_md3797"></a>
Cargo's Features (from Rust): &lt;http://doc.crates.io/manifest.html#the-features-section&gt;</h2>
<p>The proposed feature packages are exceedingly similar to Cargo's Features, with the following changes:</p>
<ul>
<li>We avoid any collision problems because features are always namespaced by the owning package</li>
<li>We do not have a concept of "feature groups", instead we allow dependencies from one feature to another within the same package (Note: This may be how "feature groups" are implemented internally to Cargo &ndash; it was not clear from the documentation).</li>
<li>Because of the nature of C and C++, it is extremely commonplace that large software packages can have features disabled to remove their dependencies upon other libraries. Changing this configuration requires a rebuild of the package and potentially rippling ABI changes to any downstream dependencies. Therefore, we expect significantly more use of this feature to manage optional API contracts instead of the intended use in Cargo (curation).</li>
<li>We do not intend feature packages to be used to express the curation relationship, beyond the notion of a "default" set within a package.</li>
</ul>
<h2><a class="anchor" id="autotoc_md3798"></a>
Gentoo's USE flags: &lt;https://wiki.gentoo.org/wiki/Handbook:X86/Working/USE&gt;</h2>
<p>Gentoo's USE flags can be shortly summarized as a global set of keywords that is used to make cross-cutting changes to the entire package graph's build configuration. This system standardizes many common settings such that they can be simultaneously toggled for the entire graph.</p>
<p>The most common example of this would be using KDE vs Gnome. A user who knows that, given the choice, they would prefer the KDE/Qt interface can manage the massive space of package configuration efficiently without learning the particular term that each package has decided to call "build using Qt instead of GTK".</p>
<p>USE flags can be customized hierarchically when needed, including at the per-package level. They can be depended upon by other packages, both positively and negatively. USE flags themselves can be used in any boolean expression to determine the complete set of package dependencies, including removing dependencies when flags are enabled.</p>
<p>Problems with USE flags:</p>
<ul>
<li>They require coordination from package maintainers to achieve the goal of "portable" flags. This increases the burden of adding a package &ndash; to author a good package, I need to be aware of every uncommon USE flag and evaluate how those could map onto my local configuration space.</li>
<li>Based on research online, it seems extremely common that users need to tweak flags at a per-package level. This calls into question how valuable the cross-cutting power above is.</li>
<li>The vast majority of common USE flags are essentially a list of all the common packages and focus on giving the user a view of dependencies (which a package manager is designed to abstract when possible) instead of APIs (which is what users code against).</li>
<li>Dependency analysis with USE flags becomes a SAT problem with an enormous state space &ndash; P*F bits &ndash; which compounds with any versioning relations. This may work acceptably in practice via heuristics, but it implies that a) there is a looming performance wall which could suddenly create a poor user experience and b) the heuristics may incorrectly model the user's needs, causing a disconnect in desire vs practice, which again leads to a poor user experience. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
